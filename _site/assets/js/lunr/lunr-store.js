var store = [{
        "title": "Program Structures and Algorithms",
        "excerpt":"What I Learned  fundamentals of programming data structures and basic algorithms  common data structures          arrays, linked list, stacks and queues, hash tables and hash maps      trees, graphs, suffix trees      other specialized data structures        order of complexities for each one of these data structures  searching and sorting  backtracking  dynamic programming  bit manipulation  pattern searching‚Ä¶Course Links  Repository  Code Lab GPA: 4.0/4.0 üíØ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/portfolio/algorithm/",
        "teaser":"http://localhost:4000/assets/images/teasers/info6205.png"},{
        "title": "Application Development and Engineering",
        "excerpt":"What I Learned  Procedural and object-oriented paradigms (in Java)  Standard data types, primitive classes, wrapper classes  OO: encapsulation, inheritance, polymorphism, and abstraction  Abstract classes, interfaces and inner classes  Exceptions and multi-threaded programming  Collection framework, Array, Collections, List, Set, and Map  File IO and exceptions handling  Building user interfaces using Java Swing                                                                                                                                                                                            Screenshots of course projects.  Course Links  Homepage  Repository  Projects          Hang Man      Game of Hearts      Inventory Management      GPA: 4.0/4.0 üíØ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/portfolio/programming/",
        "teaser":"http://localhost:4000/assets/images/application-development/inventory/inventory-ist.png"},{
        "title": "About me and this website",
        "excerpt":"My ProfessionI am studying Information Management at Northeastern University in Seattle from 2017 to 2019. Before, I was a software engineer in Oracle, and then a tech lead in Sony for 9+ years in total.My prospective profession is to be a data engineer/scientist after graduation in May 2019. So I will show some of my school/side projects on this website, including some technical articles related to java, python, web-design, database, cloud computing, big data and data science.If you would like to know more about my profession, please check my cv.My InterestsMindfulness and productivity are my most interesting subject, and I am still on my way to practice, and then build my own methodology.My other hobbies are reading, travel, and photography. I will keep writing notes and articles (mostly in Chinese) on my life blog.","categories": [],
        "tags": [],
        "url": "http://localhost:4000/mindfulness-site-launched/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "Start small, achieve BIG!",
        "excerpt":"Many people already know this, but why I mention it again, simply because it is very important and easy to forget.Nowadays, people just want to accomplish big and fancy things and tend to ignore the small ones. However, the universal law cannot be ignored that big achievements start from small.  Finishing a marathon starts with a step of running and then the next step.Writing a blog (and do not stop) is a big thing but it starts with a simple post. As to me, maybe it starts a feature of a programming language or a simple linear regression model. By keeping learning and practicing days after days, eventually, I will achieve big.2018-01-17, Seattle","categories": [],
        "tags": [],
        "url": "http://localhost:4000/start-small-achieve-big/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "Use `intertools` to solve combination and permutation problems in leetcode",
        "excerpt":"In python, package itertools  is a very powerful and efficient looping tool. Here are some examples of how to solve some leetcode algorithm problems using this tool.Quick Look at Combinatoric Iterators            Iterator      Arguments      Results                  product()      p, q, ‚Ä¶ [repeat=1]      cartesian product, equivalent to a nested for-loop              permutations()      p[, r]      r-length tuples, all possible orderings, no repeated elements              combinations()      p, r      r-length tuples, in sorted order, no repeated elements              combinations_with_replacement()      p, r      r-length tuples, in sorted order, with repeated elements              product('ABCD', repeat=2)      ¬†      AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD              permutations('ABCD', 2)      ¬†      AB AC AD BA BC BD CA CB CD DA DB DC              combinations('ABCD', 2)      ¬†      AB AC AD BC BD CD              combinations_with_replacement('ABCD', 2)      ¬†      AA AB AC AD BB BC BD CC CD DD      LeetCode Problems and SolutionsCombinationsDescriptionGiven two integers n and k, return all possible combinations of k numbers out of 1 ‚Ä¶ n.For example,If n = 4 and k = 2, a solution is:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]SolutionIt likes talored for the itertools.combinations() function. :laughing:import itertoolsclass Solution:    def combine(self, n, k):        \"\"\"        :type n: int        :type k: int        :rtype: List[List[int]]        \"\"\"        nums = [x for x in range(1, n+1)]        return list(itertools.combinations(nums, k))Combination Sum IIIDescriptionFind all possible combinations of *k* numbers that add up to a number *n*, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.*Example 1:*Input:  k = 3,  n = 7Output:[[1,2,4]]*Example 2:*Input:  k = 3,  n = 9Output:[[1,2,6], [1,3,5], [2,3,4]]Solutionimport itertoolsclass Solution:    def combinationSum3(self, k, n):        \"\"\"        :type k: int        :type n: int        :rtype: List[List[int]]        \"\"\"        if n &lt; 1 or n &gt; (1 + 9) * 9 / 2: return [] # n is too small or big        nums = [x for x in range(1, 10)] # form a list of numbers from 1 to 10 (exclusive)        return [e for e in itertools.combinations(nums, k) if sum(e) == n] # comprehensionNotereturn list(e for e in itertools.combinations(nums, k) if sum(e) == n) will also work but it is a little bit slow that the list comprehension which is used in the provided solution.PermutationsDescriptionGiven a collection of distinct numbers, return all possible permutations.For example,[1,2,3] have the following permutations:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]Solutionimport itertoolsclass Solution:    def permute(self, nums):        \"\"\"        :type nums: List[int]        :rtype: List[List[int]]        \"\"\"        return list(itertools.permutations(nums))Permutations IIDescriptionGiven a collection of numbers that might contain duplicates, return all possible unique permutations.For example,[1,1,2] have the following unique permutations:[  [1,1,2],  [1,2,1],  [2,1,1]]Solutionimport itertoolsclass Solution:    def permuteUnique(self, nums):        \"\"\"        :type nums: List[int]        :rtype: List[List[int]]        \"\"\"        return list(set(itertools.permutations(nums))) # get rid of duplicatesLimitationThe built-in function is very handy and cool. However, it is always slow to search all the combinations/permutations in a list of numbers. That‚Äôs where other algorithms like backtracking come in because it can prune the unnecessary branches when searching. Later, I will introduce the solution to these questions as well.Combination SumCombination Sum IICombination Sum IV2018-01-18, Seattle","categories": [],
        "tags": [],
        "url": "http://localhost:4000/itertools-in-leetcode/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "Get timestamp in millisecond in python 2",
        "excerpt":"Just a quick code snippet to get the millisecond in python.# python 2.ximport timeimport calendar# to get the time stamp in 1. millisecond (Linux stype from the epoch 1970-01-01 00:00:00)dt = time.strptime('1970-01-02', '%Y-%m-%d')print(dt)ts = calendar.timegm(dt)print(ts * 1000)2018-01-21, Seattle","categories": [],
        "tags": [],
        "url": "http://localhost:4000/get-timestamp-python/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "My Lynda Certificates!",
        "excerpt":"Utilize Online Learning Resource: LyndaThe university offered this great resource for students to learn online. Why not make use of it?! The overall quality of Lynda courses is great, and I can also earn some certificates and put it in linkedin.Here is some sample certificates, and click to check all my Lynda certificates. This is a small start but it will become big days after days.2018-01-21, Seattle","categories": ["learn"],
        "tags": ["certificate"],
        "url": "http://localhost:4000/learn/lynda-certificates/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "Got new skills: Spark & Scala",
        "excerpt":"As part of my knowledge base in Big Data, I completed two new certificates in Spark and Scala. My next step is to practice Kafka and Spark in two real projects, and got familiar with the APIs.2018-01-29, Seattle","categories": ["learn"],
        "tags": ["certificate"],
        "url": "http://localhost:4000/learn/spark-scala/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"},{
        "title": "Understand Idempotence of Reduce Function in MongoDB",
        "excerpt":"Here are the characteristics of Reduce Function Idempotence:  a map-reduce operation may call a reduce multiple times for the same key  it won‚Äôt call a reduce for single instances of a key in the working set  the reduce function must return a value of the same type as the value emitted from the map function.Problem: Calculate Average Price Using MapReduceDescriptionFind the average price of stock_price_high values for each stock and the total average price for all the stock using map-reduce in MongoDB.DatasetThe dataset comes from http://msis.neu.edu/nyse, and it has more than 9 million stock price records. After importing them to MongoDB database using mongdoimport command, the data format is like below.&gt; use nysedb;&gt; db.stocks.count()9211031&gt; db.stocks.findOne();{    \"_id\" : ObjectId(\"5a7158a80cf8a8197ba29570\"),    \"exchange\" : \"NYSE\",    \"stock_symbol\" : \"AEA\",    \"date\" : \"2010-02-08\",    \"stock_price_open\" : 4.42,    \"stock_price_high\" : 4.42,    \"stock_price_low\" : 4.21,    \"stock_price_close\" : 4.24,    \"stock_volume\" : 205500,    \"stock_price_adj_close\" : 4.24}Note: The collection name is ‚Äòstocks‚Äô. And here is the bash script to import this dataset.!/bin/bashFILES=NYSE/NYSE_daily_prices_*.csvfor f in $FILESdo    echo \"Processing $f file...\"    # ls -l $f    mongoimport --db nysedb --collection stocks --type csv --headerline --file $fdoneSub-Problem: Calculate the Average Price for Each StockLet‚Äôs take the stock_price_highproperty as an example to calculate the average.Approach I:  MapReduce using forEach()let map = function () {    emit(this.stock_symbol, this.stock_price_high);}let reduce = function (key, values) {  sum = 0;  num = 0;    values.forEach(function (v) {    sum += v;    num += 1;  });    if (num &gt; 0){    return sum / num;  } else {    return 0;  };}db.stocks.mapReduce(map, reduce, {out:\"mr_stock_price_avg_each\"})This job runs successfully with 9211031 inputs and 2853 outputs. And here is the result of ‚ÄúAA‚Äù.  { ‚Äú_id‚Äù : ‚ÄúAA‚Äù, ‚Äúvalue‚Äù : 64.26173484209001 }The function looks quite straightforward. Now let‚Äôs use another short version and cross-validated.Approach II: MapReduce using Array.sum()let map = function () {    emit(this.stock_symbol, this.stock_price_high);}let reduce = function (key, values) {  sum = Array.sum(values);  num = values.length;}db.stocks.mapReduce(map, reduce, {out:\"mr_stock_price_avg_each\"})Again, here is the result of ‚ÄúAA‚Äù.  { ‚Äú_id‚Äù : ‚ÄúAA‚Äù, ‚Äúvalue‚Äù : 64.26173484209001 }Validation using NoSQL AggregateThe value seems matching the previous approach. How could it be wrong? However, you will be surprised when you run this NoSQL aggregate to calculate the same average value for stock ‚ÄúAA‚Äù.&gt; db.stocks.aggregate(   [     {       $match: {stock_symbol: \"AA\"}     },     {       $group:         {           _id: \"$stock_symbol\",           avgAmount: { $avg: \"$stock_price_high\" }         }     }   ])However, the output is 52.45968205467008, which is different. Now, which one is right?Since the stock ‚ÄúAA‚Äù‚Äôs records are all in file NYSE_daily_prices_A.csv, use Excel can easily calculate the average, which is also 52.45968205. So it must be the right value. (Consider they are 52.45968205 since precision after the 7th of . does not matter much in this case.)Explanation and FixHere is the code to fix the bug.let map = function () {    emit(this.stock_symbol, {\"price\":this.stock_price_high, \"count\":1});}let reduce = function (key, values) {  reducedVal = {price: 0, count: 0}    values.forEach(function(v){    reducedVal.price += v.price;    reducedVal.count += v.count;  });    return reducedVal;}let average = function (key, reducedValue) {  return reducedValue.price / reducedValue.count;}db.stocks.mapReduce(map, reduce, {out:\"mr_stock_price_avg_each_fix\", finalize:average})But WHY?Go back and check Requirements for the reduce Function, notice this requirement:  Because it is possible to invoke the reduce function more than once for the same key, the following properties need to be true:            the type of the return object must be identical to the type of the value emitted by the mapfunction.              the reduce function must be associative. The following statement must be true:      reduce(key, [ C, reduce(key, [ A, B ]) ] ) == reduce( key, [ C, A, B ] )However, average operation is not associative. so it could not be in the reduce method.For example, considering stock ‚ÄúAA‚Äù with prices [1, 2, 6], the correct average should be 3. However, if the reduce job somehow is called twice, the first of which has input [1, 2], then the average is 1.5. Then the second call of [1.5, 6] gets 3.75 as the average, which is wrong. (Number 1.5 is the result of first reduce output.) It looks like below if you put it in the formula.  average(‚ÄúAA‚Äù, [6, average (‚ÄúAA‚Äù, [1, 2])]) ‚â† average (‚ÄúAA‚Äù, [6, 1, 2])So, it has to use a finalize method, which manipulates the result of the reduce job after it finishes.Sub-Problem: Calculate the Average Price for All StocksApproachReuse and modified the solution of the previous sub-problem. Here is the algorithm.  Have global variable sumAll to store the running sum for every occurrence of a stock  Counter the number of prices, and store in the countAll  Return a list [avgEach, avgAll] in the finalizerlet map = function () {    emit(this.stock_symbol, {\"price\":this.stock_price_high, \"count\":1});}let reduce = function (key, values) {  reducedVal = {price: 0, count: 0}    values.forEach(function(v){    reducedVal.price += v.price;    reducedVal.count += v.count;        sumAll += v.price;    countAll += v.count;  });    return reducedVal;}let avgAll = function (key, reducedValue) {  return { avg: reducedValue.price / reducedValue.count, allAvg: sumAll/countAll }}db.stocks.mapReduce(map, reduce, {out:\"mr_stock_price_avg_all\", scope:{sumAll:0, countAll:0},finalize:avgAll})Let‚Äôs check the output value of ‚ÄúAA‚Äù:{ \"_id\" : \"AA\", \"value\" : { \"avg\" : 52.459682054670246, \"allAvg\" : 32.96151152346334 } }Then validate this result using aggregation in mongo shell.&gt; db.stocks.aggregate(   [     {       $group:{         _id: null,         averageHighPrice: { $avg: \"$stock_price_high\" }       }     }   ]){ \"_id\" : null, \"averageHighPrice\" : 29.0213587773182 }What? Mismatch again!But WHY?Because the MongoDB engine won‚Äôt call a reduce for single instances of a key in the working set.To fix this problem, simply calculate the running sum and counts in the map function, because every record will be mapped no matter what.So here is the corrected solution.let map = function () {    sumAll += this.stock_price_high;    countAll += 1    emit(this.stock_symbol, {\"price\":this.stock_price_high, \"count\":1});}let reduce = function (key, values) {  reducedVal = {price: 0, count: 0}    values.forEach(function(v){    reducedVal.price += v.price;    reducedVal.count += v.count;  });    return reducedVal;}let avgAll = function (key, reducedValue) {  return { avg: reducedValue.price / reducedValue.count, allAvg: sumAll/countAll }}db.stocks.mapReduce(map, reduce, {out:\"mr_stock_price_avg_all\", scope:{sumAll:0, countAll:0},finalize:avgAll})SummaryWhen using the map-reduce, it is essential to follow the requirement of reduce function as below. Any violation may lead to incorrect result.  MongoDB will not call the reduce function for a key that has only a single value. The valuesargument is an array whose elements are the value objects that are ‚Äúmapped‚Äù to the key.  MongoDB can invoke the reduce function more than once for the same key. In this case, the previous output from the reduce function for that key will become one of the input values to the next reduce function invocation for that key.  The reduce function can access the variables defined in the scope parameter.","categories": ["database"],
        "tags": ["mongodb"],
        "url": "http://localhost:4000/database/mongodb-mapreduce/",
        "teaser":"http://localhost:4000/assets/images/default-teaser.png"}]
